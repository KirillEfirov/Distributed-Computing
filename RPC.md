# Что такое Remote Procedure Call (RPC)?

> В RPC взаимодействие между клиентом и сервером происходит так, как если бы клиентский API-запрос был локальной операцией или запрос был внутренним кодом сервера.

> Цель: RPC предназначен для облегчения организации распределенных вычислений.

> Преимущества:
> 1. Увеличение модульности и расширяемости программного обеспечения, так как позволяет разделять функционал на отдельные компоненты;
> 2. Возможность использования ресурсов удаленной машины без необходимости копирования данных или кода;
> 3. Межязыковая интероперабельность;

> Недостатки при статическом связывании:
> 1. если сервер не работает, клиент тоже не в состоянии работать;
> 2. Если сервер сменил адрес, клиент должен быть перекомпилирован с новым переходником, в котором указан новый правильный адрес;

Наибольшая эффективность использования RPC достигается в тех приложениях, в которых существует интерактивная связь между удаленными компонентами с небольшим временем ответов и относительно малым количеством передаваемых данных.

В RPC клиент отправляет запрос процессу на сервере, который постоянно прослушивает удаленные вызовы. В запросе содержится вызываемая серверная функция и все передаваемые параметры. RPC API использует в качестве базового механизма обмена данными протокол типа HTTP, TCP или UDP.

# Реализации RPC

Реализация удаленных вызовов существенно сложнее реализации вызовов локальных процедур. Начнем с того, что поскольку вызывающая и вызываемая процедуры выполняются на разных машинах, то они имеют разные адресные пространства, и это создает проблемы при передаче параметров и результатов, особенно если машины не идентичны. Так как RPC не может рассчитывать на разделяемую память, то это означает, что параметры RPC не должны содержать указателей на ячейки нестековой памяти и что значения параметров должны копироваться с одного компьютера на другой. Следующим отличием RPC от локального вызова является то, что он обязательно использует нижележащую систему связи, однако это не должно быть явно видно ни в определении процедур, ни в самих процедурах. Удаленность вносит дополнительные проблемы. Выполнение вызывающей программы и вызываемой локальной процедуры в одной машине реализуется в рамках единого процесса. Но в реализации RPC участвуют как минимум два процесса - по одному в каждой машине. В случае, если один из них аварийно завершится, могут возникнуть следующие ситуации: при аварии вызывающей процедуры удаленно вызванные процедуры станут "осиротевшими", а при аварийном завершении удаленных процедур станут "обездоленными родителями" вызывающие процедуры, которые будут безрезультатно ожидать ответа от удаленных процедур.

Кроме того, существует ряд проблем, связанных с неоднородностью языков программирования и операционных сред: структуры данных и структуры вызова процедур, поддерживаемые в каком-либо одном языке программирования, не поддерживаются точно так же во всех других языках.

Эти и некоторые другие проблемы решает широко распространенная технология RPC, лежащая в основе многих распределенных операционных систем.

Различные реализации RPC имеют очень отличающуюся друг от друга архитектуру и разнятся в своих возможностях: одни реализуют архитектуру [SOA](./Architechtural%20Models/SOA.md), другие [CORBA](./CORBA.md) или [DCOM](./DCOM.md)

# Базовые операции RPC

Чтобы понять работу RPC, рассмотрим вначале выполнение вызова локальной процедуры в обычной машине, работающей автономно. Пусть это, например, будет системный вызов

```c++
count=read (fd,buf,nbytes);
```

где fd - целое число,
buf - массив символов,
nbytes - целое число.

Чтобы осуществить вызов, вызывающая процедура заталкивает параметры в стек в обратном порядке (см. рис)
После того, как вызов read выполнен, он помещает возвращаемое значение в регистр, перемещает адрес возврата и возвращает управление вызывающей процедуре, которая выбирает параметры из стека, возвращая его в исходное состояние.

<p align='center'>
  <img src=./images/вызов-локальной-процедуры.png>
</p>

Стек до выполнения вызова read -> Стек во время выполнения процедуры -> Стек после возврата в вызывающую программу

Идея, положенная в основу RPC, состоит в том, чтобы сделать вызов удаленной процедуры выглядящим по возможности так же, как и вызов локальной процедуры. Другими словами - вызывающей процедуре не требуется знать, что вызываемая процедура находится на другой машине, и наоборот.

RPC достигает прозрачности следующим путем. Когда вызываемая процедура действительно является удаленной, в библиотеку помещается вместо локальной процедуры другая версия процедуры, называемая клиентским стабом (англ. stub - заглушка). Подобно оригинальной процедуре, стаб вызывается с использованием вызывающей последовательности, так же происходит прерывание при обращении к ядру. Только в отличие от оригинальной процедуры он не помещает параметры в регистры и не запрашивает у ядра данные, вместо этого он формирует сообщение для отправки ядру удаленной машины.

# Этапы выполнения RPC

<p align='center'>
  <img src=./images/RPC.png>
</p>

1. Вызов стаба
2. Подготовить буфер
3. Упаковать параметры
4. Заполнить поле заголовка
5. Вычислить контрольную сумму в сообщении
6. Прерывание к ядру
7. Очередь пакета на выполнение
8. Передача сообщения контроллеру по шине QBUS
9. Время передачи по сети Ethernet
10. Получить пакет от контроллера
11. Процедура обработки прерывания
12. Вычисление контрольной суммы
13. Переключение контекста в пространство пользователя
14. Выполнение серверного стаба

# Чем gRPC отличается от RPC?

[gRPC](./gRPC.md) – это система, реализующая традиционный RPC с несколькими оптимизациями. Например, gRPC использует Protocol Buffers и HTTP 2 для передачи данных.
